<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mruby | もなもなもなかのページ]]></title>
  <link href="http://www.monaka.org//blog/categories/mruby/atom.xml" rel="self"/>
  <link href="http://www.monaka.org//"/>
  <updated>2014-04-20T17:19:04+09:00</updated>
  <id>http://www.monaka.org//</id>
  <author>
    <name><![CDATA[Masaki "monaka" Muranaka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C言語における暗黙の型変換とAPI設計]]></title>
    <link href="http://www.monaka.org/blog/2014/03/19/implicit-type-conversion-in-c/"/>
    <updated>2014-03-19T14:06:12+09:00</updated>
    <id>http://www.monaka.org/blog/2014/03/19/implicit-type-conversion-in-c</id>
    <content type="html"><![CDATA[<p><a href="http://www.monaka.org/blog/2014/03/18/how-to-write-portable-api-introduction/">前口上</a>の，つづき．</p>

<h2>C言語の整数型に潜む悪夢</h2>

<p>まずは，よく知られているところから．</p>

<p>```</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>int
main(void)
{
  int a = 65535;
  char b;</p>

<p>  b = a;</p>

<p>  printf(&ldquo;%d %d\n&rdquo;, a, b);</p>

<p>  return EXIT_SUCCESS;
}
```</p>

<p>「a に 65535 を代入し，b に a の値を代入しているのだから，b も 65535 になるはず．」
などとLL言語(JavaScript や Ruby など)に慣れていると思ってしまいがちだが，そうはならない．</p>

<!-- more -->


<p>なぜなら，一般に，char 型の変数が保持できる値の範囲は，int 型の変数が保持できる値の範囲よりも小さいから．
概ね(…とボカす理由は後述)，char は -128 から 127 までの整数しか保存できない．</p>

<p>この性質は，ときどき，極めて恐ろしい．
C言語は，上の例のように保持できる値の範囲が小さい変数への代入を，エラーとして扱わない．しかしその結果は，おそらく，プログラマの期待とは異なる．
こういう挙動によるバグは，発見するのが困難なものとなる．</p>

<p>もしかしたら気の利いた処理系では警告を出してくれるかもしれないが．
しかし，私の手元にあった XCode の gcc では，割と厳格な警告を出すようオプションとして <code>-pedantic -std=c99 -W -Wall</code> を指定したが，素通りした．</p>

<p>(2014-Mar-20 補足: 上記，ちょっと筆が滑っている．ダウンキャストへの警告については<a href="/blog/2014/03/20/type-conversion-warning/">こちらのエントリ</a>もご参照頂きたい)</p>

<p>さて，それでは変数 b の型を int 型にすれば解決か?
残念ながら，それもダメ．なぜなら，int 型が保持できる整数の範囲は処理系定義であるから．
int 型のサイズが 16 ビットだったなら，保持できる整数の範囲は -32768 から 32767 までしかない．a への代入の時点で，数値が期待と異なる．
つまり，上記のリストは，ある環境では動くかもしれないが，別の環境では動かない．</p>

<p>さらに疑心暗鬼になると，char 型のサイズも実はC言語仕様は決めていない．
だからもしかすると，int 型と char 型のサイズが共に17ビット以上ある処理系なら，上記のリストは期待通りに動くかもしれない．
DSP など特殊用途のプロセッサでは，char 型が 24 ビットだったり 32 ビットだったりというのは，十分に有り得る．</p>

<p>このように，学校などで無邪気に語られる「C言語には移植性がある」などというのは嘘っぱちも甚だしい．
C言語プログラマは，細心の注意をもって，自ら移植性を担保しなければならない．</p>

<p>さて，上記をまとめると，C言語プログラミングには，次のような鉄則がある．</p>

<blockquote><p>整数型変数の代入の際には，右辺にある数値が，左辺にある変数の型に収まるかどうかを，しつこいほど気にしなければならない．</p></blockquote>

<p>以上が前提知識．本題に入る．</p>

<h2>移植性が確保できる C 言語 API</h2>

<p>C 言語 API は，(プリプロセッサマクロで書けなくも無いが)普通はC言語の関数として用意する．</p>

<p>C 言語の関数呼び出しは，値渡しだ．ポインタ渡しも，ポインタの値を渡している．
つまり，関数呼び出しにおいて，代入と同じことが起こる．</p>

<p>```</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>int
foo(char b)
{
  printf(&ldquo;%d\n&rdquo;, b);
}</p>

<p>int
main(void)
{
  int a = 65535;</p>

<p>  foo(a);</p>

<p>  return EXIT_SUCCESS;
}
```</p>

<p>このリストも，エラーも(GCCでは警告も)出ずにリンクまで通る．
代入に関する話題から判る通り printf の出力は，65535 にはならないかもしれないし，なるかもしれない．</p>

<p>ここで C言語での API 設計における鉄則が見えてくる．</p>

<blockquote><p>APIでは，暗黙の型変換を誘ってしまうような，関数宣言をしてはいけない．</p></blockquote>

<p>この鉄則を守る方法として，安直なのは，API が受け取る整数型を大きめにとっておくこと．
ダウンキャストでは値が落ちるが，アップキャスト(大きな範囲を取れる型へのキャスト)では整数が確実に代入できることは保証されている．
しかし，"安直"である理由が2つあり，お薦めはしない．</p>

<p>まず，大きな整数型というのは，コストが高いから．
CPUから見て計算コストが高い．メモリも余計に消費する．</p>

<p>そして，古めのC言語仕様では，最大の数値型が何なのか実は判らないから．
C99標準以降，処理系が扱える最大の整数型 uintmax_t ならびに intmax_t という型が規定された．しかし，分野によっては無視できないシェアを誇る Microsoft Visual C++ は，C99 への対応が中途半端で，umaxint_t, intmax_t は，定義されていない．</p>

<p>そんなわけで，API は，関数呼び出し時に，整数型のアップキャストもダウンキャストも，させてはいけない．</p>

<p>暗黙の型変換が無いとC言語のコーディングは酷く窮屈になる．
だから，C言語仕様も，容認している．
しかし，こと API についていえば，暗黙の型変換は，害悪でしかない．</p>

<p>結論として，APIでは，ユーザの関数呼び出し時に使うであろう型を，そのまま用いる，というのが唯一無二の選択となる．</p>

<h2></h2>

<p>さて，長くなった．
Matz 氏と私が，mruby の API についてどのように考えたのか．
それは<a href="/blog/2014/03/20/type-conversion-warning/">明日</a> 以降に．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C言語APIの作り方 - 前口上]]></title>
    <link href="http://www.monaka.org/blog/2014/03/18/how-to-write-portable-api-introduction/"/>
    <updated>2014-03-18T22:00:12+09:00</updated>
    <id>http://www.monaka.org/blog/2014/03/18/how-to-write-portable-api-introduction</id>
    <content type="html"><![CDATA[<h2>Twitter から</h2>

<p><a href="https://twitter.com/matsumotory/status/445772972775571456">https://twitter.com/matsumotory/status/445772972775571456</a>">https://twitter.com/matsumotory/status/445772972775571456">https://twitter.com/matsumotory/status/445772972775571456</a></a></p>

<p>というやりとりは，こちら．</p>

<p><a href="https://twitter.com/monamour555/status/445771388297564160">https://twitter.com/monamour555/status/445771388297564160</a>">https://twitter.com/monamour555/status/445771388297564160">https://twitter.com/monamour555/status/445771388297564160</a></a></p>

<p>連ツイなので，前後も読んで頂ければと．</p>

<p>ちなみに，この後，Matz 氏がコミットを一部撤回し，結局のところ，API の分裂は避けられた．</p>

<h2>やっちゃマズい fork</h2>

<p>ソフトウェア開発の世界では，やってよい fork と，やっちゃマズい fork というのがある．
やりかけておいてナンだが，API の fork は，やっちゃマズい系の最右翼だ．</p>

<!-- more -->


<p>オトナの事情で分裂したオープンソースプロジェクトは，枚挙に暇がない．
OpenOffice.org と LibreOffice，Hudson と Jenkins，などなど．
そんな事態に陥っても，せめて API は互換になるよう頑張る．</p>

<p>なぜなら，APIの分裂は，開発者の利便性を下げる．
利便性の悪いソフトは，開発者コミュニティから敬遠される．
結局のところ，分裂したプロジェクトの両方にとって損となる．</p>

<p>これは，どんなソフトウェアでも言える話ではある．
が，特にオープンソースの世界では，深刻な話となる．
開発者を惹きつけないと，旨味が出ないから．</p>

<h2>なんでそんな損な fork を?</h2>

<p>じゃあなんで，私が損な選択を敢えてしようとしたのか．</p>

<p>Matz氏がAPIを変えたいと思った理由にも，妥当性はある
(上記tweetを読めば，解る人には解る)．
そして，私の言い分にも，もちろん妥当性はある．</p>

<p>mrubyリポジトリ上の話題としては過ぎたことなので，どうでもよいといえばどうでもよいのだけれども．
C言語の入門を脱したくらいのプログラマが，再利用性の高いライブラリを作ろうと思った時に，有用かもしれないと思った．
なので，140字の行間を，私なりに(一方的に)埋めてみる．</p>

<p>今日は，話のマクラだけ．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[今日現在のmrubyについて雑想]]></title>
    <link href="http://www.monaka.org/blog/2014/01/31/memorandom-about-mruby/"/>
    <updated>2014-01-31T10:28:44+09:00</updated>
    <id>http://www.monaka.org/blog/2014/01/31/memorandom-about-mruby</id>
    <content type="html"><![CDATA[<p>なんとなく，今日現在の mruby について，私自身が薄ぼんやりと考えていることを書いておく．
なんでこのタイミングなのかに，あまり深い意味はない．
一つのきっかけとして，イベントはある．
mruby を話題の中心に据えたイベントが，<a href="http://www.digitalfukuoka.jp/events/30?locale=ja">今日の午後開催される</a>．
私も聴講者として参加する予定だ．
参加した後だと，その感想と混じる．
なんとなく私見の純度が下がるかな，とか．</p>

<p>私は，何を書いても，誰かや何かをdisっているように受け取られがちだ．
けれども，本稿もdisりの意図は全くない．
徒然なるままに．</p>

<!-- more -->


<h2>小規模組込みも視野に入れている割に，Lチカに向かない言語</h2>

<p>この tweet が象徴的だと思う．</p>

<p><a href="https://twitter.com/fenrir_n/status/428290481617780738">https://twitter.com/fenrir_n/status/428290481617780738</a>">https://twitter.com/fenrir_n/status/428290481617780738">https://twitter.com/fenrir_n/status/428290481617780738</a></a></p>

<p>IIJさんが pack/unpack を提供する mrbgem を提供しているのではあるけれども．
小規模組込みでは，ペリフェラルレジスタの操作で，ビット演算を多用する．
しかし mruby は，言語仕様からして，数値に対して態度が煮え切っていない．と，思う．</p>

<p>オブジェクト指向脳でいうと，pack/unpack じゃなくて，GPIOクラスとかSPIクラスとかを作るのが正道だろう，製品開発の実務では，それらを作りこまないでいては生産性も上がらないとも思う．</p>

<p>しかし，ボードが届いて最初にやるのは，Lチカなのだ．</p>

<p>プロジェクトのスタートアップで手間がかかるというのは，製品採用にあたっては致命的に痛い．</p>

<h2>不安定が活況を生み，それゆえ採用が難しい言語</h2>

<p>これも他人様の tweet から．</p>

<p><a href="https://twitter.com/kimu_shu/status/427641049054322688">https://twitter.com/kimu_shu/status/427641049054322688</a>">https://twitter.com/kimu_shu/status/427641049054322688">https://twitter.com/kimu_shu/status/427641049054322688</a></a></p>

<p><a href="https://twitter.com/take_cheeze/status/428792261032177664">https://twitter.com/take_cheeze/status/428792261032177664</a>">https://twitter.com/take_cheeze/status/428792261032177664">https://twitter.com/take_cheeze/status/428792261032177664</a></a></p>

<p>本家 mruby は走り続ける．
おそらく永遠に不安定だ．
それは，mruby の設計や実装がダメだからでは(もちろん)無い．
原作者である Matz 氏の根本的な考え方が反映されているものだろう．
本人が，こう tweet している．</p>

<p><a href="https://twitter.com/yukihiro_matz/status/416389827181826048">https://twitter.com/yukihiro_matz/status/416389827181826048</a>">https://twitter.com/yukihiro_matz/status/416389827181826048">https://twitter.com/yukihiro_matz/status/416389827181826048</a></a></p>

<blockquote><p>タダ乗りしただけでは置いて行かれてしまう進化の速さ</p></blockquote>

<p>こういった性質は，ハッカーと呼ばれる人たちのマインドに火をつけやすい．
実際，あっというまに mrbgem が量産された．
今では Ruby の代替として考えてもよいのでは，と思える程の充実ぶりだ．</p>

<p>この性質は，機器組込み屋にとっては，酷く辛く痛い．
他の保守部品と同様に，機器組込み向けソフトウェアも，バージョン固定するのが基本線だから．</p>

<h2>とはいえ，安定版にあまり意味は無い</h2>

<p>mruby が抱えるサグラダ・ファミリア的性質と，機器組込み業界との親和性の無さは，私もどこかに登壇するたびに言ってきた．</p>

<p>その言動と関係があるのかどうかは知らないが，mrubyを担いでいる方々も，安定版を出す方向で動いているらしい．
私は軽量Rubyフォーラムに参加していないので，詳しいことは知らない．</p>

<p>安定版の登場は，確かに，ビジネス的には意味がある．
開発者をかき集めるときに，スキルセットを設定しやすくなる．
応用製品を作る際に，準拠バージョンを設定しやすくなる．</p>

<p>こういったメリットは，非技術系経営層への対策としては，一定の意味がある．とても大事なことだ．しかし，技術者たちは，あまり歓迎しないかもしれない．</p>

<p>安定していることを再優先にしつつも， <strong>最新版に最も近いもの</strong> を，機器組込み系エンジニアは，使いたがる傾向がある．
バージョン固定で永く付き合うことになるので，最初の時点で古いのは嫌なのだ．</p>

<p>なので，機器組込み系エンジニアは，安定版を採用しないだろう．
安定版が 3ヶ月おきに更新される，というような，想像しづらいリリース体制が構築されれば別だが．</p>

<p>かつて「プロジェクトの数だけITRONは存在する」と言われたように，「プロジェクトの数だけ mruby が存在する」というような状況が展開されると予測する．
コード規模で見ても，mruby は ITRON に各種ミドルウェアを付けた状態と概ね似ているので，同じような運用が為される可能性は高い．
規格適合のための処理系テストスイートが，もてはやされることになるだろう．</p>

<p>歴史に学ぶ，という観点では，TOPPERSプロジェクトの第一世代カーネル群が，おそらく参考になる．
FI4カーネルは新規設計したほうが綺麗になるのは明らかだったのに，JSPカーネルへの拡張で済むように作った．
そのようにした理由はいくつかあるが，JSPカーネルとFI4カーネルの中間的なカーネルを，実製品開発プロジェクト毎に作れるようにしたかったから．
設計思想としては，mruby と mrbgems の関係に割と近い．
そして，FI4カーネルは，目論見通りに使われた．</p>

<p>だから何なのだ，という話ではないのだけれど．
過去の分析と近未来予測は，使い方を考える上で重要だろうとは思う．</p>

<p>あ，ぐだぐだ書いていたら，そろそろ会場へ向かう時間だ．
そろそろ着替えるか．</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mruby | もなもなもなかのページ]]></title>
  <link href="http://www.monaka.org//blog/categories/mruby/atom.xml" rel="self"/>
  <link href="http://www.monaka.org//"/>
  <updated>2014-06-15T12:52:44+09:00</updated>
  <id>http://www.monaka.org//</id>
  <author>
    <name><![CDATA[Masaki "monaka" Muranaka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[monami-ya.mrb が sandbox サポートを追加する理由]]></title>
    <link href="http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support-2/"/>
    <updated>2014-06-15T09:58:37+09:00</updated>
    <id>http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support-2</id>
    <content type="html"><![CDATA[<p><a href="http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support/">先ほど</a>の続き．</p>

<p><a href="https://twitter.com/monamour555/status/477722322862759938">https://twitter.com/monamour555/status/477722322862759938</a>">https://twitter.com/monamour555/status/477722322862759938">https://twitter.com/monamour555/status/477722322862759938</a></a></p>

<p>など言って，実装理由を詳説しないのは，ちょっとイケ好かないかなということで．</p>

<p>本題に入るには，OS が提供する thread の使い方について，寄り道をする必要があります．</p>

<p>注: 本稿は，mruby の内部構造，特に，mrb_state と mrbgems の関係を理解していることを前提にしています．</p>

<!-- more -->


<h2>thread の使い方，2通り</h2>

<p>thread は，たかが機構なので，使い方は幾通りもありえます．</p>

<p>しかし，代表的なパターンとして，2通りの使い方があります．
たぶんデザインパターン的な名前がありそうですが，知らないのでオレオレ命名で．</p>

<h3>対称(symmetric)なスレッド</h3>

<p>同じデータ構造で同じ処理を持つスレッドが，多数あるパターンです．</p>

<p>非同期に起こる多数の要求を裁くときに，しばしば見られます．
具体例としては，サーバのワーカースレッドや，ファイルシステム内の処理などがあります．</p>

<p><img src="symmetric.png" alt="対称なスレッド" /></p>

<h3>非対称なスレッド</h3>

<p>複数のスレッドが，それぞれ異なるデータ構造を管理するパターンです．
データ構造が異なるのですから，各スレッドが行う処理も，当然異なります．</p>

<p>「そういう時はプロセス分けるだろ」と思った方は，POSIX や Windows に頭を侵されています．</p>

<p>多くの RTOS では，スレッドに相当する概念はあります．
しかし，プロセスに相当するリソース抽象化概念がありません．(注: 持っている RTOS もあります)</p>

<p>また，POSIX や Windows も，OS の内部では，スレッドに相当する概念はありますが，リソース抽象化の概念は無いか，希薄です．
OSが抽象化を提供しているので，当然です．</p>

<p><img src="asymmetric.png" alt="非対称なスレッド" /></p>

<h2>mruby のスレッドバインディングとmrbgems</h2>

<p>mruby は，言語としては，今のところスレッドを提供していません．
しかし，マルチスレッディングの要求は，上記の2通りのいずれにせよ，間違いなくあります．</p>

<p>mruby を下位 OS のスレッドとバインドする典型的手法として，スレッド毎に mrb_state を割り当てる手法があります．</p>

<p>私は mod_mruby のソースコードを精読したわけではないですが．
サーバへの mruby 活用の代表である， mod_mruby も，Apache のワーカースレッドに対し 1 つの mrb_state を割り当てているようです．
この場合は，各スレッドは「対称」です．
全ての mrb_state は，同じように初期化されて構いません．
使える mrbgems も全てのスレッド(mrb_state)で同じもので構いません．</p>

<h2>さて，本稿の本題．</h2>

<p>非対称なスレッド構成を取ったシステムを考えてみます．</p>

<p>実例として，uITRON, OSEK/VDX クラスの RTOS 上にファイルシステムとユーザアプリを mruby のみで作るとします．</p>

<p>構成としては，デバドラ + ファイルシステム + ユーザアプリになります．</p>

<p>デバドラとファイルシステムは，再利用性が高いので，おそらく mrbgems として実装するでしょう．
そして，非同期処理になりますので，(デバドラ + ファイルシステム)のスレッドと，ユーザアプリのスレッドに分けるでしょう．スレッド間通信も mrbgems として提供するかもしれません．
常識的な RTOS のアプリ設計です．</p>

<p>ここで，思い出してみましょう．
現在の mruby では，全ての mrb_state で，全ての mrbgems を共有します．
つまり，スレッドを分けても，ユーザアプリは，ファイルシステムを迂回して直接デバドラのメソッドを叩けます．</p>

<p><img src="sandbox.png" alt="sandboxの有無と非対称スレッド" /></p>

<p>これを気持ち悪くないと思う開発者が居たとしたら，別の職種にジョブチェンジしたほうがよいでしょう．</p>

<h2>なぜ他のmruby開発者はsandboxを必要と思わないのか．</h2>

<p>今のところ，mruby へ sandbox を仕掛ける実装は殆どみかけません．
mattn 氏が <a href="https://github.com/mattn/mruby-sandbox">mruby-sandbox</a> なる実験をしてはいますけれども．
私はかつて，<a href="https://github.com/mruby/mruby/pull/1844">lazy initialization なる提案</a>をしていて，これは sandbox を狙ったものだったのですが，意図がうまく伝わらなかったのか，フルボッコに終わりました．</p>

<p>実のところ，彼らでないので真の理由は解りません．
しかし，私の想像が及ぶ限りにおいて，必要と思わない理由は，2種類あります．</p>

<h3>説: Web サーバくらいまでしか考えてない</h3>

<p>ひとつは，"くみこみ！"など言いながらも，結局 web サーバのことまでしか考えが及ばないから．
対称なスレッドだけですむ世界なら，今の実装でも十分です．</p>

<p>もちろん，世界最高水準の開発者集団ですから，非対称スレッドの設計についても，頭では理解できておられるでしょう．
それと，腹に落として理解できるというのは，必ずしも一致しません．
技術というものの難しいところであります．</p>

<h3>説: コードゴルフに偏りすぎている</h3>

<p>もう一つは，組み込み系技術者たちは，小さな機器組み込みに偏りすぎているから．
ちっちゃいもの好きは，ニッポンの組み込みのガラパゴ特徴ですが，mruby も漏れずに思えます．
Mindstorms/NXT やらFM3-USBSTICKやら STM32F4 やら，RTOSを載せるのさえも一苦労な環境に，開発者たちの視線が集中しています．</p>

<p>コードゴルフは私も嫌いではないですが．
現在でもオンチップ 256KB は珍しくないマイコン世界．
MB 級の RAM がオンチップになるのは時間の問題なのになぁ…．
盆栽みたいなものですかね．</p>

<p>ともあれ，mrb_state をひとつ持たせるのがやっとの環境では，スレッドと mrb_state の組が複数存在する環境で起こることを想定するのは難しいでしょう．
私は，Mocloudos や mruby + TOPPERS + Blackfin といった，潤沢なスペックを持つ(とはいってもデスクトップやサーバに比べると極めて貧弱な)環境上で mruby を動作させています．
そのため，早期に気がついた，ということはあるでしょう．</p>

<h2></h2>

<p>というわけで，mruby で sandbox が何故必要なのか，なぜ本家に登場しないのか，ざざっと意見表明いたしました．</p>

<p>こう言ってはナンですが，今の体制のままだと，本家mrubyが機器組み込みに応用されるようになるのは，ずいぶんと先になるんじゃないかな…．</p>

<p>まあ，別に，"本家"に拘る必要も無いといえば無いのですが．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[monami-ya.mrb での sandbox サポート]]></title>
    <link href="http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support/"/>
    <updated>2014-06-15T08:45:14+09:00</updated>
    <id>http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support</id>
    <content type="html"><![CDATA[<p>たぶん会社の公式サイトに乗るべき情報のような気もしますが．
まだ master ブランチどころか develop ブランチにも入っていないので，メモとして，こちらに書いておきます．</p>

<p>mruby の機器組み込み向け fork である monami-ya.mrb に，mrbgems の sandbox 機能を追加しました．
何故この機能が必要なのか，という話は<a href="http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support-2/">後日する</a>として，どう使うかということを記しておきます．
master ブランチに入るまでに，API 等の変更があるかもしれません．</p>

<p>また，mruby 本体に取り込まれるかどうかは，解りません．</p>

<h2>機能概要</h2>

<!-- more -->


<h3>前提知識</h3>

<p>本家 mruby では，mrbgems による機能拡張がサポートされています．
これは，monami-ya.mrb でも同様です．</p>

<p>mruby は，複数の実行環境を持てます．
実行環境は mrb_state という構造体が代表します．</p>

<p>mrb_state は，mrb_open() の呼び出しによって作成されます．
mrb_open() の実行時には，build_config.rb で静的に指定した全ての mrbgems が，
mrb_state で使用するものとして初期化されます．</p>

<h3>sandbox が提供する機能</h3>

<p>mrb_state ごとに，利用する mrbgems を限定できます．
限定する mrbgems は，静的に指定します．</p>

<h2>実装</h2>

<p>実例として，monami-ya-mrb/mruby-sqlite3 と monami-ya-mrb/mruby-bin-sqlite3 のみを含む sandbox を挙げます．</p>

<p>monami-ya-mrb/mruby-sqlite3 は monami-ya-mrb/mruby-bin-sqlite3 に依存しています．</p>

<h3>build_config.rb への記述</h3>

<p>build_config.rb に，sandbox メソッドを記述できるようになりました．</p>

<p>```
MRuby::CrossBuild.new(&lsquo;jsp-bfin&rsquo;) do |conf|
&hellip;
  conf.sandbox(&lsquo;sqlite&rsquo;) do</p>

<pre><code>gem :github =&gt; 'monami-ya-mrb/mruby-sqlite3'
gem :github =&gt; 'monami-ya-mrb/mruby-bin-sqlite3'
</code></pre>

<p>  end
&hellip;
```</p>

<p>この例では &lsquo;sqilte&rsquo; という名前の sandbox を指定しています．
ブロック内の gem は，従来のと同じです．</p>

<p>このような記述があるとき，minirake を実行すると，build/jsp-bfin/mrbgems/gem_init.c には，従来に加えていくつかの定義が生成されます．</p>

<p>```
void
mrb_init_sqlite_sandbox(mrb_state *mrb) {
  GENERATED_TMP_mrb_mruby_bin_sqlite3_gem_init(mrb);
  GENERATED_TMP_mrb_mruby_sqlite3_gem_init(mrb);
}</p>

<p>void
mrb_final_sqlite_sandbox(mrb_state *mrb) {
  GENERATED_TMP_mrb_mruby_bin_sqlite3_gem_final(mrb);
  GENERATED_TMP_mrb_mruby_sqlite3_gem_final(mrb);
}</p>

<p>struct mrb_sandbox_inib mrb_sandbox_inib_array[] = {
  {</p>

<pre><code>mrb_init_sqlite_sandbox,
mrb_final_sqlite_sandbox,
</code></pre>

<p>  },
  { NULL, NULL }
};
```</p>

<p>さらに， build/jsp-bfin/mrb_sandbox_id.h というヘッダファイルが生成されます．</p>

<p>```
/<em>
 * IMPORTANT:
 *   This file was generated!
 *   All manual changes will get lost.
 </em>/</p>

<h1>define MRB_SANDBOX_SQLITE (1u)</h1>

<p>```</p>

<h3>依存性チェック</h3>

<p>もし， mruby-sqlite3 のみを指定し，依存性のある mruby-bin-sqlite3 を
含め忘れたとします．</p>

<p>```
MRuby::CrossBuild.new(&lsquo;jsp-bfin&rsquo;) do |conf|
&hellip;
  conf.sandbox(&lsquo;sqlite&rsquo;) do</p>

<pre><code>gem :github =&gt; 'monami-ya-mrb/mruby-sqlite3'
</code></pre>

<p>  end
&hellip;
```</p>

<p>このような依存性の破れを含む記述で minirake を実行した場合には，エラーとなります．</p>

<p><code>
(in /Users/monaka/git/monami-ya.mrb/monami-ya.mrb)
rake aborted!
GEM mruby-bin-sqlite3 not found in the sandbox `sqlite'
rakefile:27:in `load'
</code></p>

<h3>実行時の sandbox 生成</h3>

<p>API として mrb_open_sandbox() および mrb_open_sandbox_allocf() が追加になりました．</p>

<p><code>
mrb_state* mrb_open_sandbox(unsigned int sandbox_id);
mrb_state* mrb_open_sandbox_allocf(mrb_allocf, uintptr_t ud, unsigned int sandbox_id);
</code></p>

<p>引数 sandbox_id は，mrb_sandbox_id.h にある定義を与えます．</p>

<p><code>
  mrb = mrb_open_sandbox(MRB_SANDBOX_SQLITE);
</code></p>

<p>sandbox_id が 0 のときは，mrb_open() を呼んだ時と同じになります．
すなわち，登録されている全ての mrbgems が初期化されます．</p>

<p>どの sandbox を指定したかは，mrb_state に保持されます．
そのため，mrb_state を破棄する際には，単に mrb_close() を呼び出してください．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[過去の事例だとこの手のOSSは長期的には失われる結果になりそうです]]></title>
    <link href="http://www.monaka.org/blog/2014/05/31/fork-will-dead-itself-exactly/"/>
    <updated>2014-05-31T18:52:30+09:00</updated>
    <id>http://www.monaka.org/blog/2014/05/31/fork-will-dead-itself-exactly</id>
    <content type="html"><![CDATA[<p>おお，さすが OSS 世界の長老．キレの良い予言でございます．</p>

<p><a href="https://twitter.com/yukihiro_matz/status/472033974219325440">https://twitter.com/yukihiro_matz/status/472033974219325440</a>">https://twitter.com/yukihiro_matz/status/472033974219325440">https://twitter.com/yukihiro_matz/status/472033974219325440</a></a></p>

<!--
https://twitter.com/yukihiro_matz/status/472033974219325440
@monamour555 まあ、どうforkするかはご自由で私から強制することはできませんが、過去の事例だとこの手のforkしたOSSは長期的には失われる結果になりそうです。
-->


<p>全く御意でございます．低頭拝聴です．</p>

<p>賤民である私も，OSS という言葉が無かったころ，Ruby が世に放流された頃には，この世界を見ていた気も無くもないですが．
きっと気のせいですね．
uClinux, Xen, Android で kernel の fork が起こったのは，失われる運命だったのですね．だめだ fork はダメだ．失われる！だめだ！</p>

<h2>やっぱ fork はダメだ失われる！</h2>

<p>あーやっぱり，私が書いたコードなんて，消えちゃうよなー．すべからく，そういう人生だったしなー．何しろ長老がそう言っているもんなー．
って陰惨に思いながら，残りのコードを書いていたのですが．</p>

<p>…あれ?</p>

<!-- more -->


<p>コンパイルが通らないよ?</p>

<p><code>
mrb_proc_new(mrb, mrb-&gt;irep[n],
</code></p>

<blockquote><p>んー? んー? ググル先生に聞いても解法がわからないよー．コピペできなよー．えーん．
こんな単純なところでコピペできない OSS なんか，使えないよー．マサカリ担いだ人しか使えない処理系なんてー (棒</p></blockquote>

<h2>自分で fork しまくる OSS は長期的には失われれる運命になりそうです．</h2>

<p>あはは，忘れていました．
IREP の扱い方，途中で，変わりました．
mruby のコア開発者なら，当たり前の知識ですよね．アテクシ，死ねばいいのに．</p>

<p>コードベースの進化は，OSS の華です．いいんじゃないですかね，
ただし，ユーザがその変更についていけていない OSS が，長期的には失われなかったのかな．</p>

<h2>タマにはマジメに．</h2>

<p>賤民の私に言わせてもらえるなら，これ，良くない兆候ですよ．</p>

<p>この節だけは，マジメに言いますけれど．</p>

<p>私が fork したコードなんてどうでもよいです．</p>

<p>良くない兆候ですよ． マージされ得ないオレオレ fork を繰り返して周りがついてこれなくなっている，<strong><em>本家のコード</em></strong> が．</p>

<p>過去の事例によると．
ブログエントリって，エッジ効いた技術に平民がどれだけついてこれているかを示す，解りやすい指標ですからね．</p>

<p>何言ってやがるんだと思うなら， mrb_proc_new か何かでググりゃいいんじゃないですかね．
軒なみ mrb->irep[n] ですから，記述が．少なくとも本稿執筆時点では．</p>

<p>角が立つのを承知で，(でももう，どーでもいいので)，事例を言えば，uT 以降の T-kernel とか，新世代以降の TOPPERS とかですね．
技術的に正しいながらも，説明不十分でプレゼンスを落としたOSS，しばしば見かけるのは気のせいですかね．</p>

<p>mruby，どうなのですかね? &ldquo;長期的な視点"を持っているグルには，答えが見えているに違いない．信じるのじゃ．
…ので，大丈夫ですかね．</p>

<p>どうなのですかね?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C言語における暗黙の型変換とAPI設計]]></title>
    <link href="http://www.monaka.org/blog/2014/03/19/implicit-type-conversion-in-c/"/>
    <updated>2014-03-19T14:06:12+09:00</updated>
    <id>http://www.monaka.org/blog/2014/03/19/implicit-type-conversion-in-c</id>
    <content type="html"><![CDATA[<p><a href="http://www.monaka.org/blog/2014/03/18/how-to-write-portable-api-introduction/">前口上</a>の，つづき．</p>

<h2>C言語の整数型に潜む悪夢</h2>

<p>まずは，よく知られているところから．</p>

<p>```</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>int
main(void)
{
  int a = 65535;
  char b;</p>

<p>  b = a;</p>

<p>  printf(&ldquo;%d %d\n&rdquo;, a, b);</p>

<p>  return EXIT_SUCCESS;
}
```</p>

<p>「a に 65535 を代入し，b に a の値を代入しているのだから，b も 65535 になるはず．」
などとLL言語(JavaScript や Ruby など)に慣れていると思ってしまいがちだが，そうはならない．</p>

<!-- more -->


<p>なぜなら，一般に，char 型の変数が保持できる値の範囲は，int 型の変数が保持できる値の範囲よりも小さいから．
概ね(…とボカす理由は後述)，char は -128 から 127 までの整数しか保存できない．</p>

<p>この性質は，ときどき，極めて恐ろしい．
C言語は，上の例のように保持できる値の範囲が小さい変数への代入を，エラーとして扱わない．しかしその結果は，おそらく，プログラマの期待とは異なる．
こういう挙動によるバグは，発見するのが困難なものとなる．</p>

<p>もしかしたら気の利いた処理系では警告を出してくれるかもしれないが．
しかし，私の手元にあった XCode の gcc では，割と厳格な警告を出すようオプションとして <code>-pedantic -std=c99 -W -Wall</code> を指定したが，素通りした．</p>

<p>(2014-Mar-20 補足: 上記，ちょっと筆が滑っている．ダウンキャストへの警告については<a href="/blog/2014/03/20/type-conversion-warning/">こちらのエントリ</a>もご参照頂きたい)</p>

<p>さて，それでは変数 b の型を int 型にすれば解決か?
残念ながら，それもダメ．なぜなら，int 型が保持できる整数の範囲は処理系定義であるから．
int 型のサイズが 16 ビットだったなら，保持できる整数の範囲は -32768 から 32767 までしかない．a への代入の時点で，数値が期待と異なる．
つまり，上記のリストは，ある環境では動くかもしれないが，別の環境では動かない．</p>

<p>さらに疑心暗鬼になると，char 型のサイズも実はC言語仕様は決めていない．
だからもしかすると，int 型と char 型のサイズが共に17ビット以上ある処理系なら，上記のリストは期待通りに動くかもしれない．
DSP など特殊用途のプロセッサでは，char 型が 24 ビットだったり 32 ビットだったりというのは，十分に有り得る．</p>

<p>このように，学校などで無邪気に語られる「C言語には移植性がある」などというのは嘘っぱちも甚だしい．
C言語プログラマは，細心の注意をもって，自ら移植性を担保しなければならない．</p>

<p>さて，上記をまとめると，C言語プログラミングには，次のような鉄則がある．</p>

<blockquote><p>整数型変数の代入の際には，右辺にある数値が，左辺にある変数の型に収まるかどうかを，しつこいほど気にしなければならない．</p></blockquote>

<p>以上が前提知識．本題に入る．</p>

<h2>移植性が確保できる C 言語 API</h2>

<p>C 言語 API は，(プリプロセッサマクロで書けなくも無いが)普通はC言語の関数として用意する．</p>

<p>C 言語の関数呼び出しは，値渡しだ．ポインタ渡しも，ポインタの値を渡している．
つまり，関数呼び出しにおいて，代入と同じことが起こる．</p>

<p>```</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>int
foo(char b)
{
  printf(&ldquo;%d\n&rdquo;, b);
}</p>

<p>int
main(void)
{
  int a = 65535;</p>

<p>  foo(a);</p>

<p>  return EXIT_SUCCESS;
}
```</p>

<p>このリストも，エラーも(GCCでは警告も)出ずにリンクまで通る．
代入に関する話題から判る通り printf の出力は，65535 にはならないかもしれないし，なるかもしれない．</p>

<p>ここで C言語での API 設計における鉄則が見えてくる．</p>

<blockquote><p>APIでは，暗黙の型変換を誘ってしまうような，関数宣言をしてはいけない．</p></blockquote>

<p>この鉄則を守る方法として，安直なのは，API が受け取る整数型を大きめにとっておくこと．
ダウンキャストでは値が落ちるが，アップキャスト(大きな範囲を取れる型へのキャスト)では整数が確実に代入できることは保証されている．
しかし，"安直"である理由が2つあり，お薦めはしない．</p>

<p>まず，大きな整数型というのは，コストが高いから．
CPUから見て計算コストが高い．メモリも余計に消費する．</p>

<p>そして，古めのC言語仕様では，最大の数値型が何なのか実は判らないから．
C99標準以降，処理系が扱える最大の整数型 uintmax_t ならびに intmax_t という型が規定された．しかし，分野によっては無視できないシェアを誇る Microsoft Visual C++ は，C99 への対応が中途半端で，umaxint_t, intmax_t は，定義されていない．</p>

<p>そんなわけで，API は，関数呼び出し時に，整数型のアップキャストもダウンキャストも，させてはいけない．</p>

<p>暗黙の型変換が無いとC言語のコーディングは酷く窮屈になる．
だから，C言語仕様も，容認している．
しかし，こと API についていえば，暗黙の型変換は，害悪でしかない．</p>

<p>結論として，APIでは，ユーザの関数呼び出し時に使うであろう型を，そのまま用いる，というのが唯一無二の選択となる．</p>

<h2></h2>

<p>さて，長くなった．
Matz 氏と私が，mruby の API についてどのように考えたのか．
それは<a href="/blog/2014/03/20/type-conversion-warning/">明日</a> 以降に．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C言語APIの作り方 - 前口上]]></title>
    <link href="http://www.monaka.org/blog/2014/03/18/how-to-write-portable-api-introduction/"/>
    <updated>2014-03-18T22:00:12+09:00</updated>
    <id>http://www.monaka.org/blog/2014/03/18/how-to-write-portable-api-introduction</id>
    <content type="html"><![CDATA[<h2>Twitter から</h2>

<p><a href="https://twitter.com/matsumotory/status/445772972775571456">https://twitter.com/matsumotory/status/445772972775571456</a>">https://twitter.com/matsumotory/status/445772972775571456">https://twitter.com/matsumotory/status/445772972775571456</a></a></p>

<p>というやりとりは，こちら．</p>

<p><a href="https://twitter.com/monamour555/status/445771388297564160">https://twitter.com/monamour555/status/445771388297564160</a>">https://twitter.com/monamour555/status/445771388297564160">https://twitter.com/monamour555/status/445771388297564160</a></a></p>

<p>連ツイなので，前後も読んで頂ければと．</p>

<p>ちなみに，この後，Matz 氏がコミットを一部撤回し，結局のところ，API の分裂は避けられた．</p>

<h2>やっちゃマズい fork</h2>

<p>ソフトウェア開発の世界では，やってよい fork と，やっちゃマズい fork というのがある．
やりかけておいてナンだが，API の fork は，やっちゃマズい系の最右翼だ．</p>

<!-- more -->


<p>オトナの事情で分裂したオープンソースプロジェクトは，枚挙に暇がない．
OpenOffice.org と LibreOffice，Hudson と Jenkins，などなど．
そんな事態に陥っても，せめて API は互換になるよう頑張る．</p>

<p>なぜなら，APIの分裂は，開発者の利便性を下げる．
利便性の悪いソフトは，開発者コミュニティから敬遠される．
結局のところ，分裂したプロジェクトの両方にとって損となる．</p>

<p>これは，どんなソフトウェアでも言える話ではある．
が，特にオープンソースの世界では，深刻な話となる．
開発者を惹きつけないと，旨味が出ないから．</p>

<h2>なんでそんな損な fork を?</h2>

<p>じゃあなんで，私が損な選択を敢えてしようとしたのか．</p>

<p>Matz氏がAPIを変えたいと思った理由にも，妥当性はある
(上記tweetを読めば，解る人には解る)．
そして，私の言い分にも，もちろん妥当性はある．</p>

<p>mrubyリポジトリ上の話題としては過ぎたことなので，どうでもよいといえばどうでもよいのだけれども．
C言語の入門を脱したくらいのプログラマが，再利用性の高いライブラリを作ろうと思った時に，有用かもしれないと思った．
なので，140字の行間を，私なりに(一方的に)埋めてみる．</p>

<p>今日は，話のマクラだけ．</p>
]]></content>
  </entry>
  
</feed>

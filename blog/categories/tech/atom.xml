<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | もなもなもなかのページ]]></title>
  <link href="http://www.monaka.org//blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://www.monaka.org//"/>
  <updated>2014-06-17T12:24:22+09:00</updated>
  <id>http://www.monaka.org//</id>
  <author>
    <name><![CDATA[Masaki "monaka" Muranaka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[RTOS は monami-ya.mrb を遅くするか?]]></title>
    <link href="http://www.monaka.org/blog/2014/06/17/rtos-makes-mruby-slow-p/"/>
    <updated>2014-06-17T11:01:52+09:00</updated>
    <id>http://www.monaka.org/blog/2014/06/17/rtos-makes-mruby-slow-p</id>
    <content type="html"><![CDATA[<p>とある，案件契約ではない非公式なやりとりから．
個人が特定されるような内容ではないので，これくらいなら許され…ますよね．</p>

<blockquote><p>mruby 自身もC言語に比べて処理に時間がかかるところに，RTOSが入るとさらに遅くなったりしないのか少し心配です．</p></blockquote>

<p>同じような直感を持たれる方，案外多いのではないかなと思います．
機器組み込み業界で働いておられるエンジニアの中にもいらっしゃるのではないかな，とも．</p>

<p>端的に言うと，RTOS が入ると遅くなるというのは，概ね誤解です．
いやもちろん RTOS がゼロオーバヘッドだと言っているわけではありません．</p>

<p>いまや<a href="http://www.monami-ya.jp/product/monami-ya.mrb/about/index.html">会社の製品の機能として提供されている部分</a>なので，本来なら会社の公式ページに書くべきところですが，そうすると定量計測してホワイトペーパーにしないと格好がつきません．
そこまで喫緊の話でもない(非公式なやりとりですし)ので，こちらに書いておきます．</p>

<h2>RTOS とは何か?</h2>

<!-- more -->


<h3>そもそも OS とは何か</h3>

<p>RTOS の前に OS とは何か，から確認していきましょう．
多くのデスクトップ環境では，CPUのコア数はたかがか8個程度でしょうけれども，OS上ではより多くのCPUが存在しているかのように見えています．
本当は1つしかないメモリ空間は，MMUなどメモリ管理ハードウェアの支援を得て，プロセス毎に分けつつも，プロセス内では全メモリを専有しているように見せかけています．
ストレージも，本当は1つしかなくても，ファイルシステムという構造を導入することで，複数のプロセスに競合しないように調停されます．</p>

<p>ざっくり言うと，OS というのは，何かを抽象化し管理し保護するソフトウェアです．
現在的なOSのほとんどは，プロセスと呼ぶ抽象化した計算機を管理し，処理がプロセスから外に漏れないようにして，物理的な計算機資源を保護しています．</p>

<h3>RTOS は何を保護するものか</h3>

<p>RTOS の抽象化対象は，CPUです．
実際には全ての処理は時分割されているのですが，それぞれの処理はCPUを専有しているものと(RTOSによって)勘違いさせられています．
そして保護対象は，RT == Real Time が示す通り，時間です．
なので，多くの RTOS は時間以外のリソースの保護については，かなり無頓着です．
最近になって，セキュリティについての世論が固まったため，リソース保護機能付きのRTOSも増えました．
それでも，リソース保護機能が時間保護を阻害するとなれば，時間保護のほうが優先されます．</p>

<p>ここでいう時間には，2種類あります．</p>

<p>ひとつは物理時間です．これは一般的な「壁時計」と同じと思って頂いて構いません．
RTOS自身オーバヘッドが影響するので重要といえば重要なのですが，CPUに与えるクロック次第で改善されやすいものでもあります．</p>

<p>もう一つは実行順序制約です．RTOS ではこちらのほうが重要です．
RTOS では，実行順序が事前に見積もれなければならない，とされます．
そして，優先されるべき処理については，他の処理を止めてでも実行して良い，とされます．
他の処理を止めれば，実行順序を見積もりやすくなりますから．</p>

<p>通常のOSにも優先度の概念はあります．しかしRTOSの場合は強烈です．
アプリケーション設計者が必要と思うなら，デバイスへの割り込みすら止めることができます．
CPUが持つ計算資源の全てを，特定の処理に割り当てられるというのが，RTOS の特徴です．</p>

<p>RTOS は時間を管理する OS なので，これは当然の特徴と言えます．
(計算資源 == 計算に要するクロック数 == 時間)ですから．</p>

<h2>RTOS のオーバヘッド</h2>

<p>RTOS は，複数の処理(タスク)に対して，CPU が複数あるように見せかける抽象化を行っています．
抽象化の裏には，オーバヘッドがあります．
これは，時間量として見ると，コンテキストスイッチに要する時間で表されます．
商用 RTOS の星取表で，この数値が俎上に上がっているのを見たことがある方も多いでしょう．</p>

<p>あまりにも商用 RTOS の営業さん達がけたたましく言うので，このオーバヘッドが無視できないと誤解する方が後を絶ちません．
しかし実際のところ，このオーバヘッドが致命的かどうかは，アプリケーションに依ります．</p>

<p>mruby は，大目に見ても C言語で書くよりも2桁のオーダで遅くなります．
「週に何度も口にしない飴玉のカロリーを気にするなら，まず毎日の三食を見直しましょう」という喩えでお分かり頂けますでしょうか．</p>

<p>なお，RTOS のオーバヘッドとして有名な指標には，コンテキストスイッチの他に，割り込みへの応答時間もあります．
こちらも，似たような議論が成り立ちます．</p>

<h2>「RTOS は重い」神話の，ミもフタもない理由</h2>

<p>とはいえ，「RTOS は重い」にも相応の理由は思いつきます．
それは，優先度設計の難しさ，です．</p>

<p>既述の通り，RTOS では，高優先度の処理は，CPUへの割り込みさえも止められます．
このような条件で，高優先度で実行される処理の設計が悪くCPUを専有した場合は，システムは最悪の状態になります．
低優先度の処理にはいつまでたっても，処理の機会が与えられません．
(ちなみに，このような状態に陥った低優先度の処理は，RTOS 界隈の用語では，"飢餓状態"としばしば言われます．)</p>

<p>日本の組み込み業界では，優先度設計から詳細実装まで全てを一人でこなす例もありますが，
上流が検討もしないで適当に優先度を割り振った仕様書を元に，受託で(再受託で(再々受託で))詳細を実装するということが，しばしば行われます．
こういうケースでは，組み上げてみたら真っ当に動かない，ということは，珍しくなかったりします．</p>

<p>それは設計の不備であり，RTOS が悪いわけではないのですが．
外から買ってきた RTOS をスケープゴートにする，ということが起こるのは，人として理解できないわけでもありません．</p>

<h2>monami-ya.mrb は，RTOS で処理が重くなったりはしません．</h2>

<p>…もちろん，高優先度の処理で無限ループなどされるとダメですけれども．</p>

<p>優先度の設定に気をつけている限りにおいて，monami-ya.mrbはRTOSと併用しても処理が重くなったりはしません．
その辺りには，20年前から RTOS 関わり，TOPPERS/FI4 など RTOS の実装にも関わった経験を活かしてあります．</p>

<p>本家 mruby は…? メモリアロケータの部分をキチンとケアできれば，大丈夫にできると思いますよ．たぶん．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[monami-ya.mrb が sandbox サポートを追加する理由]]></title>
    <link href="http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support-2/"/>
    <updated>2014-06-15T09:58:37+09:00</updated>
    <id>http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support-2</id>
    <content type="html"><![CDATA[<p><a href="http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support/">先ほど</a>の続き．</p>

<p><a href="https://twitter.com/monamour555/status/477722322862759938">https://twitter.com/monamour555/status/477722322862759938</a>">https://twitter.com/monamour555/status/477722322862759938">https://twitter.com/monamour555/status/477722322862759938</a></a></p>

<p>など言って，実装理由を詳説しないのは，ちょっとイケ好かないかなということで．</p>

<p>本題に入るには，OS が提供する thread の使い方について，寄り道をする必要があります．</p>

<p>注: 本稿は，mruby の内部構造，特に，mrb_state と mrbgems の関係を理解していることを前提にしています．</p>

<!-- more -->


<h2>thread の使い方，2通り</h2>

<p>thread は，たかが機構なので，使い方は幾通りもありえます．</p>

<p>しかし，代表的なパターンとして，2通りの使い方があります．
たぶんデザインパターン的な名前がありそうですが，知らないのでオレオレ命名で．</p>

<h3>対称(symmetric)なスレッド</h3>

<p>同じデータ構造で同じ処理を持つスレッドが，多数あるパターンです．</p>

<p>非同期に起こる多数の要求を裁くときに，しばしば見られます．
具体例としては，サーバのワーカースレッドや，ファイルシステム内の処理などがあります．</p>

<p><img src="symmetric.png" alt="対称なスレッド" /></p>

<h3>非対称なスレッド</h3>

<p>複数のスレッドが，それぞれ異なるデータ構造を管理するパターンです．
データ構造が異なるのですから，各スレッドが行う処理も，当然異なります．</p>

<p>「そういう時はプロセス分けるだろ」と思った方は，POSIX や Windows に頭を侵されています．</p>

<p>多くの RTOS では，スレッドに相当する概念はあります．
しかし，プロセスに相当するリソース抽象化概念がありません．(注: 持っている RTOS もあります)</p>

<p>また，POSIX や Windows も，OS の内部では，スレッドに相当する概念はありますが，リソース抽象化の概念は無いか，希薄です．
OSが抽象化を提供しているので，当然です．</p>

<p><img src="asymmetric.png" alt="非対称なスレッド" /></p>

<h2>mruby のスレッドバインディングとmrbgems</h2>

<p>mruby は，言語としては，今のところスレッドを提供していません．
しかし，マルチスレッディングの要求は，上記の2通りのいずれにせよ，間違いなくあります．</p>

<p>mruby を下位 OS のスレッドとバインドする典型的手法として，スレッド毎に mrb_state を割り当てる手法があります．</p>

<p>私は mod_mruby のソースコードを精読したわけではないですが．
サーバへの mruby 活用の代表である， mod_mruby も，Apache のワーカースレッドに対し 1 つの mrb_state を割り当てているようです．
この場合は，各スレッドは「対称」です．
全ての mrb_state は，同じように初期化されて構いません．
使える mrbgems も全てのスレッド(mrb_state)で同じもので構いません．</p>

<h2>さて，本稿の本題．</h2>

<p>非対称なスレッド構成を取ったシステムを考えてみます．</p>

<p>実例として，uITRON, OSEK/VDX クラスの RTOS 上にファイルシステムとユーザアプリを mruby のみで作るとします．</p>

<p>構成としては，デバドラ + ファイルシステム + ユーザアプリになります．</p>

<p>デバドラとファイルシステムは，再利用性が高いので，おそらく mrbgems として実装するでしょう．
そして，非同期処理になりますので，(デバドラ + ファイルシステム)のスレッドと，ユーザアプリのスレッドに分けるでしょう．スレッド間通信も mrbgems として提供するかもしれません．
常識的な RTOS のアプリ設計です．</p>

<p>ここで，思い出してみましょう．
現在の mruby では，全ての mrb_state で，全ての mrbgems を共有します．
つまり，スレッドを分けても，ユーザアプリは，ファイルシステムを迂回して直接デバドラのメソッドを叩けます．</p>

<p><img src="sandbox.png" alt="sandboxの有無と非対称スレッド" /></p>

<p>これを気持ち悪くないと思う開発者が居たとしたら，別の職種にジョブチェンジしたほうがよいでしょう．</p>

<h2>なぜ他のmruby開発者はsandboxを必要と思わないのか．</h2>

<p>今のところ，mruby へ sandbox を仕掛ける実装は殆どみかけません．
mattn 氏が <a href="https://github.com/mattn/mruby-sandbox">mruby-sandbox</a> なる実験をしてはいますけれども．
私はかつて，<a href="https://github.com/mruby/mruby/pull/1844">lazy initialization なる提案</a>をしていて，これは sandbox を狙ったものだったのですが，意図がうまく伝わらなかったのか，フルボッコに終わりました．</p>

<p>実のところ，彼らでないので真の理由は解りません．
しかし，私の想像が及ぶ限りにおいて，必要と思わない理由は，2種類あります．</p>

<h3>説: Web サーバくらいまでしか考えてない</h3>

<p>ひとつは，"くみこみ！"など言いながらも，結局 web サーバのことまでしか考えが及ばないから．
対称なスレッドだけですむ世界なら，今の実装でも十分です．</p>

<p>もちろん，世界最高水準の開発者集団ですから，非対称スレッドの設計についても，頭では理解できておられるでしょう．
それと，腹に落として理解できるというのは，必ずしも一致しません．
技術というものの難しいところであります．</p>

<h3>説: コードゴルフに偏りすぎている</h3>

<p>もう一つは，組み込み系技術者たちは，小さな機器組み込みに偏りすぎているから．
ちっちゃいもの好きは，ニッポンの組み込みのガラパゴ特徴ですが，mruby も漏れずに思えます．
Mindstorms/NXT やらFM3-USBSTICKやら STM32F4 やら，RTOSを載せるのさえも一苦労な環境に，開発者たちの視線が集中しています．</p>

<p>コードゴルフは私も嫌いではないですが．
現在でもオンチップ 256KB は珍しくないマイコン世界．
MB 級の RAM がオンチップになるのは時間の問題なのになぁ…．
盆栽みたいなものですかね．</p>

<p>ともあれ，mrb_state をひとつ持たせるのがやっとの環境では，スレッドと mrb_state の組が複数存在する環境で起こることを想定するのは難しいでしょう．
私は，Mocloudos や mruby + TOPPERS + Blackfin といった，潤沢なスペックを持つ(とはいってもデスクトップやサーバに比べると極めて貧弱な)環境上で mruby を動作させています．
そのため，早期に気がついた，ということはあるでしょう．</p>

<h2></h2>

<p>というわけで，mruby で sandbox が何故必要なのか，なぜ本家に登場しないのか，ざざっと意見表明いたしました．</p>

<p>こう言ってはナンですが，今の体制のままだと，本家mrubyがベアメタルな機器組み込みに応用されるようになるのは，ずいぶんと先になるんじゃないかな…．</p>

<p>まあ，別に，"本家"に拘る必要も無いといえば無いのですが．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[monami-ya.mrb での sandbox サポート]]></title>
    <link href="http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support/"/>
    <updated>2014-06-15T08:45:14+09:00</updated>
    <id>http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support</id>
    <content type="html"><![CDATA[<p>たぶん会社の公式サイトに乗るべき情報のような気もしますが．
まだ master ブランチどころか develop ブランチにも入っていないので，メモとして，こちらに書いておきます．</p>

<p>mruby の機器組み込み向け fork である monami-ya.mrb に，mrbgems の sandbox 機能を追加しました．
何故この機能が必要なのか，という話は<a href="http://www.monaka.org/blog/2014/06/15/monami-ya-dot-mrb-sandbox-support-2/">後日する</a>として，どう使うかということを記しておきます．
master ブランチに入るまでに，API 等の変更があるかもしれません．</p>

<p>また，mruby 本体に取り込まれるかどうかは，解りません．</p>

<h2>機能概要</h2>

<!-- more -->


<h3>前提知識</h3>

<p>本家 mruby では，mrbgems による機能拡張がサポートされています．
これは，monami-ya.mrb でも同様です．</p>

<p>mruby は，複数の実行環境を持てます．
実行環境は mrb_state という構造体が代表します．</p>

<p>mrb_state は，mrb_open() の呼び出しによって作成されます．
mrb_open() の実行時には，build_config.rb で静的に指定した全ての mrbgems が，
mrb_state で使用するものとして初期化されます．</p>

<h3>sandbox が提供する機能</h3>

<p>mrb_state ごとに，利用する mrbgems を限定できます．
限定する mrbgems は，静的に指定します．</p>

<h2>実装</h2>

<p>実例として，monami-ya-mrb/mruby-sqlite3 と monami-ya-mrb/mruby-bin-sqlite3 のみを含む sandbox を挙げます．</p>

<p>monami-ya-mrb/mruby-sqlite3 は monami-ya-mrb/mruby-bin-sqlite3 に依存しています．</p>

<h3>build_config.rb への記述</h3>

<p>build_config.rb に，sandbox メソッドを記述できるようになりました．</p>

<p>```
MRuby::CrossBuild.new(&lsquo;jsp-bfin&rsquo;) do |conf|
&hellip;
  conf.sandbox(&lsquo;sqlite&rsquo;) do</p>

<pre><code>gem :github =&gt; 'monami-ya-mrb/mruby-sqlite3'
gem :github =&gt; 'monami-ya-mrb/mruby-bin-sqlite3'
</code></pre>

<p>  end
&hellip;
```</p>

<p>この例では &lsquo;sqilte&rsquo; という名前の sandbox を指定しています．
ブロック内の gem は，従来のと同じです．</p>

<p>このような記述があるとき，minirake を実行すると，build/jsp-bfin/mrbgems/gem_init.c には，従来に加えていくつかの定義が生成されます．</p>

<p>```
void
mrb_init_sqlite_sandbox(mrb_state *mrb) {
  GENERATED_TMP_mrb_mruby_bin_sqlite3_gem_init(mrb);
  GENERATED_TMP_mrb_mruby_sqlite3_gem_init(mrb);
}</p>

<p>void
mrb_final_sqlite_sandbox(mrb_state *mrb) {
  GENERATED_TMP_mrb_mruby_bin_sqlite3_gem_final(mrb);
  GENERATED_TMP_mrb_mruby_sqlite3_gem_final(mrb);
}</p>

<p>struct mrb_sandbox_inib mrb_sandbox_inib_array[] = {
  {</p>

<pre><code>mrb_init_sqlite_sandbox,
mrb_final_sqlite_sandbox,
</code></pre>

<p>  },
  { NULL, NULL }
};
```</p>

<p>さらに， build/jsp-bfin/mrb_sandbox_id.h というヘッダファイルが生成されます．</p>

<p>```
/<em>
 * IMPORTANT:
 *   This file was generated!
 *   All manual changes will get lost.
 </em>/</p>

<h1>define MRB_SANDBOX_SQLITE (1u)</h1>

<p>```</p>

<h3>依存性チェック</h3>

<p>もし， mruby-sqlite3 のみを指定し，依存性のある mruby-bin-sqlite3 を
含め忘れたとします．</p>

<p>```
MRuby::CrossBuild.new(&lsquo;jsp-bfin&rsquo;) do |conf|
&hellip;
  conf.sandbox(&lsquo;sqlite&rsquo;) do</p>

<pre><code>gem :github =&gt; 'monami-ya-mrb/mruby-sqlite3'
</code></pre>

<p>  end
&hellip;
```</p>

<p>このような依存性の破れを含む記述で minirake を実行した場合には，エラーとなります．</p>

<p><code>
(in /Users/monaka/git/monami-ya.mrb/monami-ya.mrb)
rake aborted!
GEM mruby-bin-sqlite3 not found in the sandbox `sqlite'
rakefile:27:in `load'
</code></p>

<h3>実行時の sandbox 生成</h3>

<p>API として mrb_open_sandbox() および mrb_open_sandbox_allocf() が追加になりました．</p>

<p><code>
mrb_state* mrb_open_sandbox(unsigned int sandbox_id);
mrb_state* mrb_open_sandbox_allocf(mrb_allocf, uintptr_t ud, unsigned int sandbox_id);
</code></p>

<p>引数 sandbox_id は，mrb_sandbox_id.h にある定義を与えます．</p>

<p><code>
  mrb = mrb_open_sandbox(MRB_SANDBOX_SQLITE);
</code></p>

<p>sandbox_id が 0 のときは，mrb_open() を呼んだ時と同じになります．
すなわち，登録されている全ての mrbgems が初期化されます．</p>

<p>どの sandbox を指定したかは，mrb_state に保持されます．
そのため，mrb_state を破棄する際には，単に mrb_close() を呼び出してください．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EC2でXenのmini-osを動かす手順]]></title>
    <link href="http://www.monaka.org/blog/2014/02/04/how-to-build-ebs-image/"/>
    <updated>2014-02-04T10:26:39+09:00</updated>
    <id>http://www.monaka.org/blog/2014/02/04/how-to-build-ebs-image</id>
    <content type="html"><![CDATA[<h1>余談</h1>

<p>最近，mruby を動作させる超軽量クラウドOSなんてのを，なんちゃってで作っている．
ざっくりとした経過は，先週末くらいからtwitterで呟いている．</p>

<p>一応，会社を持っているので，そちらで展開することは不可能ではなさげではある．
でも開発資金もないし市場も立ち上がっている風でもない．ネタ系で済ましておいたほうが，傷を負わなくて済むような気もする．
資金力が十分にあるならば，大学に持ちかけて共同研究でも始めちゃうようなネタという気もするのだが．
思案の最中．
うだつが上がらんと，ほんと，なんにもできないねぇ．
やだやだ．</p>

<p>閑話休題．</p>

<h1>まくら</h1>

<p>そのOSは，Xen の mini-os (厳密にいうと stubdom)をベースにしているので，Amazon EC2 でも動作する．
Amazon が提供していないカーネルを独自に EC2 で動作させるためには，どうやら EBS ボリュームを作らねばならないらしい．
私は，AWS の単なるユーザで，細かいところはあまり詳しくない．
よって，EBS ボリューム以外での起動方法もあるのかもしれないが…．</p>

<p>手順は本家ヘルプページに割と細かく説明されている．
解説ブログも，ググれば山盛り．
さすがは，みんな大好きAWS．</p>

<p>だがしかし，最近になって，AWS は，管理ツールを AWS-CLI というものに統合しようとしている一方，本家ヘルプページは，AWS-CLI への対応が十分にできていない．</p>

<p>そこで，本稿では，AWS-CLI で mini-os をブートさせるための手順を記す．</p>

<!-- more -->


<h1>作業</h1>

<h2>概要</h2>

<p>独自のカーネルをEC2上で動作させるためのイメージ(以下，オレオレイメージ)は，EBS のスナップショットから作るようになっている．
Xen ではおなじみの PV-GRUB が，オレオレイメージ中にある boot/grub/menu.lst を読み，
kernel (本稿の場合は mini-os)をロードしブートする．
手元環境でEBSを作ってアップロードすることもできるのかもしれないが(知らない)，ここでは EC2 上で t1.micro を立ち上げて作業する．
一連の作業時間は，1時間もかからない．t1.micro なら10円にも満たないような額だろう．</p>

<p>本稿では，ビルドは手元で行うことを想定している．ビルド環境さえもEC2上に立てるということも，もちろんできる．
その際の作業の読み替え箇所は，いちいち言及するまでも無いだろう．</p>

<h2>手順0: ~/.aws/config</h2>

<p>こんな感じ．</p>

<p><code>
[default]
aws_access_key_id=ないしょ
aws_secret_access_key=ないしょ
region=ap-northeast-1
output=text
</code></p>

<p>region が違うと，下記例示の image-id やらなにやら変更が要るかもしれない．</p>

<h2>手順1: EBSボリュームへのアクセスを行う EC2 インスタンスの生成</h2>

<p>EC2のインスタンスを立ち上げる．</p>

<p><code>
$ aws ec2 run-instances --image-id ami-dcfa4edd --instance-type t1.micro --security-group-ids quick-start-1 --key-name monaka
</code></p>

<p>&mdash;security-groups-ids や &mdash;key-name は，ご自分の環境に合わせて．
&mdash;image-id も，好みの環境があるなら，それで．
でも，本稿の例だと複雑なことはしないので，amiの選択に凝るのは時間の無駄かも．</p>

<p>結果はこんな感じ．</p>

<p><code>
578606849602    r-351e1831
GROUPS  sg-e242dbe3 quick-start-1
INSTANCES   0   i386    None    False   xen ami-dcfa4edd    i-a3bec9a4  t1.micro    aki-ec5df7ed    monaka  2014-02-01T11:04:33.000Z    None    None    /dev/sda1   ebs None    paravirtual
MONITORING  disabled
PLACEMENT   ap-northeast-1b None    default
SECURITYGROUPS  sg-e242dbe3 quick-start-1
STATE   0   pending
STATEREASON pending pending
</code></p>

<h2>手順2: 諸々のファイルを入れるEBSボリュームの生成</h2>

<p><code>
$ aws ec2 create-volume --size 1 --availability-zone ap-northeast-1b
</code>
mini-os のサイズは1MB以下なのだが，EBSボリュームの最低サイズは1GB．無駄だがやむなし．</p>

<p>結果はこんな感じ．</p>

<p><code>
ap-northeast-1b 2014-02-01T10:46:19.012Z    1   None    creating    vol-1cbb4b16    standard
</code></p>

<h2>手順3: EBSボリュームのEC2インスタンスへのアタッチ</h2>

<p><code>
Monacintosh:~ monaka$ aws ec2 attach-volume --volume-id vol-1cbb4b16 --instance-id i-a3bec9a4 --device /dev/sdh1
</code>
vol-1cbb4b16 は，手順2の結果で得られたもの．i-a3bec9a4 は，手順1の結果で得られたもの．</p>

<p>結果はこんな感じ．</p>

<p><code>
2014-02-01T11:05:25.613Z    /dev/sdh1   i-a3bec9a4  attaching   vol-1cbb4b16
</code></p>

<h2>手順4: 作業用 EC2 インスタンスへの ssh ログイン</h2>

<p>手順1で，インスタンスを立ち上げた直後は，サーバのFQDNが判らない．
そろそろインスタンスのプロビジョニングも終わっているはずなので，確認．</p>

<p><code>
$ aws ec2 describe-instances --instance-ids i-a3bec9a4
</code></p>

<p>結果はこんな感じ</p>

<p><code>
RESERVATIONS    578606849602    r-351e1831
GROUPS  sg-e242dbe3 quick-start-1
INSTANCES   0   i386    None    False   xen ami-dcfa4edd    i-a3bec9a4  t1.micro    aki-ec5df7ed    monaka  2014-02-01T11:04:33.000Z    ip-10-132-154-11.ap-northeast-1.compute.internal    10.132.154.11   ec2-54-199-18-76.ap-northeast-1.compute.amazonaws.com   54.199.18.76    /dev/sda1   ebs None    paravirtual
BLOCKDEVICEMAPPINGS /dev/sda1
EBS 2014-02-01T11:04:36.000Z    True    attached    vol-69bc4c63
MONITORING  disabled
PLACEMENT   ap-northeast-1b None    default
SECURITYGROUPS  sg-e242dbe3 quick-start-1
STATE   16  running
</code>
compute.amazonaws.com で終わっているのが，外向きのFQDN．
今回の場合は，ec2-54-199-18-76.ap-northeast-1.compute.amazonaws.com
なので，おもむろに ssh．</p>

<p>Amazon Linux の場合は，ログインユーザは ec2-user となる．</p>

<p><code>
$ ssh ec2-user@ec2-54-199-18-76.ap-northeast-1.compute.amazonaws.com
</code></p>

<p>サーバの公開鍵を受け入れるかどうかなど聞かれる．
結果は，こんな感じ．</p>

<p>```
The authenticity of host &lsquo;ec2-54-199-18-76.ap-northeast-1.compute.amazonaws.com (54.199.18.76)&rsquo; can&rsquo;t be established.
RSA key fingerprint is e8:10:70:59:ce:4b:7b:59:97:92:35:d8:35:a7:3a:92.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &lsquo;ec2-54-199-18-76.ap-northeast-1.compute.amazonaws.com,54.199.18.76&rsquo; (RSA) to the list of known hosts.</p>

<pre><code>   __|  __|_  )
   _|  (     /   Amazon Linux AMI
  ___|\___|___|
</code></pre>

<p>See /usr/share/doc/system-release/ for latest release notes.
No packages needed for security; 170 packages available
Amazon Linux version 2013.09 is available.
[ec2-user@ip-10-132-154-11 ~]$
```</p>

<h2>手順5: EBSボリュームのマウント</h2>

<p>手順3では，EBSボリュームはアタッチしかしていない．
ここでファイルシステムを作成して，マウントする．</p>

<p>ファイルシステムの生成は，こんな感じ．</p>

<p><code>
[ec2-user@ip-10-132-154-11 ~]$ sudo mkfs.ext2 /dev/sdh1
</code></p>

<p>結果は，こんな感じ．</p>

<p>```
mke2fs 1.41.12 (17-May-2010)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
65536 inodes, 262144 blocks
13107 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=268435456
8 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:</p>

<pre><code>32768, 98304, 163840, 229376
</code></pre>

<p>Writing inode tables: done                          <br/>
Writing superblocks and filesystem accounting information: done</p>

<p>This filesystem will be automatically checked every 24 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
```</p>

<p>ファイルシステムはできたので，早速マウント．</p>

<p><code>
[ec2-user@ip-10-132-154-11 ~]$ sudo mount /dev/sdh1 /mnt
</code></p>

<p>特にメッセージの出力など無く，コマンドプロンプトに戻ってくる．</p>

<h2>手順6: menu.lst の生成</h2>

<p>PV-GRUB が読む menu.lst を，EBSボリューム(の中にあるファイルシステム)に置く．
エディタ使ってもいいけれど，この程度なら猫で十分．</p>

<p>```
[root@ip-10-132-154-11 ec2-user]# sudo -s
[root@ip-10-132-154-11 ec2-user]# cat > /mnt/boot/grub/menu.lst
default 0</p>

<p>title MiniOS test</p>

<pre><code>    root (hd0)
    kernel /mini-os
</code></pre>

<p>[root@ip-10-132-154-11 ec2-user]# exit
```</p>

<p>sudo -s を使ったので，最後には exit で，ec2-user に戻しておいた．</p>

<h2>手順7: mini-os のコピー</h2>

<p>何らかの方法で行う．
ふつうは scp を使うと思う．
そして，EC2 インスタンス上の /mnt/mini-os に配置する．
ここでmenu.lst の記述に引っ張られて，うっかり，/mini-os に置いたりとかしないように．</p>

<h2>手順8: スナップショットの生成</h2>

<p>手順7までで，EC2インスタンスは用済みとなる．
だから，stop-insrance なり terminate-instance なりで落としてもよい．
けれども，最初の動作確認ができるまでは，立ち上げっぱなしのほうがよいかもしれない．
EC2の課金は1時間単位だけれども，1時間以内にn回立ち上げ直すと，n時間分の料金になる．</p>

<p>EC2のインスタンスにアタッチしたままでも，スナップショットは取れる．
そうでないと，スナップショットの意味が無い．</p>

<p>操作は，こんな感じ．</p>

<p><code>
$ aws ec2 create-snapshot --volume-id vol-1cbb4b16
</code></p>

<p><code>
結果は，こんな感じ．
None    578606849602    None    snap-940d6c7a   2014-02-01T11:24:16.000Z    pending vol-1cbb4b16    1
</code></p>

<h2>手順9: スナップショットからオレオレイメージの生成</h2>

<p>いよいよ佳境．スナップショットからオレオレイメージを生成する．
正直言うと，よく調べがついていないのだけれど，イメージの概要を示すjsonファイルが必要らしい．
短いものなので，これもテキストエディタを持ち出すまでもないはず．</p>

<p>```
$ cat > blockdevice.json
[</p>

<pre><code>    {"DeviceName":"/dev/xvda","Ebs":{"VolumeType":"standard","DeleteOnTermination":true,"VolumeSize":1,"SnapshotId":"snap-940d6c7a"}}
</code></pre>

<p>]
```</p>

<p>VolumeSize は，最初に 1GB で作ったから．SnapshotId は，手順8の出力と合わせる．</p>

<p>そして，イメージの登録を行う．</p>

<p><code>
$ aws ec2 register-image --root-device-name /dev/xvda --name "Mini-os test" --block-device-mappings file://blockdevice.json --architecture x86_64
</code></p>

<p>結果は，こんな感じ．
<code>
ami-ef650eee
</code></p>

<h2>手順10: オレオレイメージの起動</h2>

<p>そして感動のフィナーレ．オレオレイメージの起動．</p>

<p><code>
$ aws ec2 run-instances --image-id ami-ef650eee --instance-type t1.micro --security-group-ids quick-start-1 --key-name monaka
</code></p>

<p>結果は，こんな感じ</p>

<p><code>
578606849602    r-f17d65f5
GROUPS  sg-e242dbe3 quick-start-1
INSTANCES   0   x86_64  None    False   xen ami-ef650eee    i-b38630b4  t1.micro    monaka  2014-02-01T11:46:28.000Z    None    None    /dev/xvda   ebs None    paravirtual
MONITORING  disabled
PLACEMENT   ap-northeast-1b None    default
SECURITYGROUPS  sg-e242dbe3 quick-start-1
STATE   0   pending
STATEREASON pending pending
</code></p>

<p>これだけだと，本当に立ち上がったのか判らない．</p>

<p>ログの取得は，こんな感じで行う．</p>

<p><code>
$ aws ec2 get-console-output --instance-id i-b38630b4
</code></p>

<p>i-b38630b4 は，オレオレイメージの run-instance の結果から引っ張ってくる．</p>

<p>mini-os 自身は小さいものの，mini-os の実行環境のプロビジョニングには，そこそこの時間がかかる．
遅い時は5分以上かかるので，気長に待つ．
どうせ1時間までは同じ時間だから．</p>

<h1>雑感</h1>

<p>EC2 == クラウド == インフラ屋さんやWeb屋さん</p>

<p>という第一印象を持つかもしれないが，stubdom は，newlibだのlwIPだの使っていて，技術要素としては，むしろ組込み屋の定番ライブラリで成り立っている．</p>

<p>2000年ごろには，IOKit を用いてオレオレOSを作るのが流行ったが，同様に，オレオレクラウドOSを作るのが地味に流行るかもしれない．
情報量が少なくて，とっかかりは辛いが，#kernelvm の常連発表者のレベルであれば，たぶん半日のハッカソンで，何らか創り出せるだろう．そんな気がする．</p>
]]></content>
  </entry>
  
</feed>
